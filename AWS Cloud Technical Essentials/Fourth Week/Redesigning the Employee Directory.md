Let's take a look at how this architecture we built turned out. 
# __
![[Pasted image 20230708195459.png]]
The employee directory application is currently being hosted across multiple EC Two instances inside of a VPC in a private subnet. These EC Two instances are part of an EC Two auto-scaling group. And traffic is being distributed across them using an application load balancer. The database is being hosted on Amazon DynamoDB. And the images are stored in S3. 
# __
Beautiful. Looking at this from a maintenance perspective, you would need to ensure that your auto-scaling policies are working well with your expectations and it would likely take some tweaking over time. You also would need to install security patches and updates for EC Two, as well as keep an eye out for new instant sizes or types that might help you further optimize your solution. Now, this is really great. But as with everything built on AWS, there are multiple ways you can architect a solution and have success. It really depends on what you are optimizing for and what you are trying to do that will determine how you architect an application. That being said, what I want to do now, is present to you an architecture that could be a wonderful serverless redesign of the employee directory application, taking full advantage of cloud native services like AWS Lambda. I'm going to touch on some services we haven't covered yet in this course to give you ideas of alternative architectures. 
# __
![[Pasted image 20230708195734.png]]
So this employee directory application is a great example of a standard three-tier application, where you have the presentation layer, the application layer, and the data layer. The presentation layer is the user interface. The application layer is the business logic. And the data layer is the database. As things are right now, the Amazon EC Two instances are hosting both the presentation layer, as well as the application layer. 
# __
This is true because the EC Two instances have a web server running that is serving the content for the website, like the HTML, CSS, and JavaScript, which is the presentation layer. Then the same instances are also handling requests for the backend logic for viewing, adding, updating and deleting employees, which is the application layer. What I want to do now is separate those two pieces entirely, having the front-end of the website hosted separately from the backend application logic. It's important to separate the presentation layer from the application layer so that the instances are not overloaded by handling different types of requests at the same time.
# __
![[Pasted image 20230708195838.png]]
We're going to move the presentation layer to be hosted out of Amazon S3. S3 supports static website hosting, and therefore this is a great place for us to host the HTML, CSS and JavaScript for our website. When you're hosting a static website with S3, you may think, "Well, my website isn't static. It's dynamic." It's pulling data from a database, so this isn't a static website, and therefore S3 would not work for this use case. This is where JavaScript comes in. 
# __
![[Pasted image 20230708200115.png]]
JavaScript files have the ability to make HTTP requests and load dynamic content, modifying the static page to display results that come back from requests. So this should work well. 
# __
![[Pasted image 20230708200349.png]]
The presentation layer is taken care of. Now, I want to tackle the application layer. It used to be hosted on Amazon EC Two. But let's go ahead and change this to AWS Lambda. This means that our employee directory application code would only be run in response to events being triggered by the front-end presentation layer. Now, you don't want your front-end talking directly to your backend code. So you would instead expose your backend using an API. We would use a service Amazon API Gateway to host this API. Each action you could take on an employee would have its own method on the API. This API hosted on API Gateway would act as a front door to trigger the backend code, which we would host on AWS Lambda instead of EC Two as discussed. We could have one Lambda function handle all of the requests for employee data, or we could have one Lambda function for each action. We would keep DynamoDB for the database or the data layer, and we would also keep S3 for the employee photo storage. All of the access between these services would be handled via role-based access using IAM roles. 
# __
One nice thing about this, is notice how, because we built the solution in a modular way, we were able to swap out how we were handling the presentation and application layer while leaving the data layer totally intact with no modifications. That is the type of flexibility that can help you innovate and adapt quickly to changes. 
# __
![[Pasted image 20230708200602.png]]
So now for completeness and clarity, let's focus on the new architecture and fill it out a bit more. I will add some other AWS services to this diagram that you can explore on your own. First, I'm going to add Amazon Route 53 for domain name management and Amazon Cloud front here as well, which will allow us to cash those static assets like the HTML, CSS and JavaScript, closer to the end users by taking advantage of AWS Edge locations. If a user wants to visit the employee directory application website and view all of its employees, here's the flow. The user would first type in the domain for the website, which would get sent to Amazon Route 53. Route 53 would send back to the client the address of the static website being hosted on S3, and then the website would be rendered in the browser. This website has JavaScript making the API calls to the backend to load the dynamic content. So the API call to load all of the employees would be made and it would hit API Gateway first. API Gateway would validate the request and then trigger the backend Lambda function. The Lambda function would then send an API call to DynamoDB to query the employees in the table and it would return that data to API Gateway, which would then be returned to the JavaScript, which would finally be rendered on the page. All right, and that's that. With this architecture we just laid out, we have optimized for scalability, operational overhead, and depending on your usage, it could also be optimized for cost. 
# __
The serverless aspects of this make the operations for support much less than compared with Amazon EC Two based workloads. There is no patching, or AMI management, when you use serverless solutions like AWS Lambda. Also, notice how it was not required that I create a VPC, subnets, security groups, or network access control list for the solution. The networking aspect of this is managed for you. Though, you can integrate serverless services with your VPC if you need to, for compliance reasons. But it's not required to get a solution up and running. 
# __
You have many options to choose from when designing your application. You can imagine a scenario where you redesign the same application to be hosted using AWS container services, and then this entire diagram would change again. There are a lot of ways you can build on AWS and that's the beauty of it. You can swap certain pieces of your solutions out as AWS services are released or gain new features. And because everything in AWS is an API call, you can automate the process along the way. That's it for this course.
# __
![[Pasted image 20230708200807.png]]
###### One more reminder to please, remember to delete any resources that you've created in your own AWS account for this class to avoid incurring any costs if you've been following along.