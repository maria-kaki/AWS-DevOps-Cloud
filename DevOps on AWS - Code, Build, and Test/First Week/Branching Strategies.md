![[index (4) 1.mp4]]
As a development team, we'll need to decide on a branching strategy. This will help us answer some questions every dev team needs to answer, like what code are we running in production right now? That information can be very handy to have, so we know what is currently deployed, or can reproduce a bug that is happening in production. Where should I put my commits for something that isn't ready to go to production? If I'm working on a feature, but it is going to take several weeks to complete, I don't want it to be included in any upcoming production deployments. Our solution to this question needs to scale to the multiple engineers working on multiple features. Conversely, where do I put my commits for something that needs to go to production immediately? We might need to roll out a feature to production in a fast production hotfix. If we don't have a way of doing this, we run the risk of having a broken product until the next production deploy, or not being able to react quickly to a security issue.
# __
We're going to walk through one way of approaching this and we can see how this answers the questions we've raised. Again, this is something that you will decide on as a team, and work in a process that works best for the team. Before we get too deep into our strategies here, let's take a second to remember what branches are in Git. A branch in Git is a pointer to a commit, and that's it. When we make a commits in a branch, the pointer automatically moves forward. One more thing to remember, your commits form a DAG, or directed acyclic graph. A commit can also have multiple parents. In fact, this is exactly what a merge commit does. When you merge a feature branch into main, the merge commit has two parents. The main branch now points at this merge commit and commits from both parents are now in the branch history. All right, I'm going to pass this off to Russ, so he can get a bit deeper into these branching strategies.
# __
- [Russ] Let's define some conventions for our branching strategy. We start with the main branch. we have commits on a main branch. Everything in main is in production, or about to be deployed very soon. When a production deploy happens, we take the commit that was deployed. This tag answers the question, what is the code that is running in production right now? I've talked to a product manager about an update to our application. Let's say, we're going to improve the user registration process. Where do I put the commits for this?
# __
As a team, we've decided to create feature branches. We branch from the tip of main. I can continue committing to my feature branch. I might have continuous integration testing the code quality, and continuous deployment deploying to a staging environment, where stakeholders can see the work in progress.
# __
I've finished on my feature. Now, let's get this in front of customers. It's time to get my commits into the main branch, ready for deployment. I want to give others on the team an opportunity to review and comment on the update. So, I create a pull request in CodeCommit. From my repository, I click Create pull request. The destination for my new feature is main, and the source is the feature branch. I'm being told what I have is mergeable. Let's remember, I'm not the only one on the team who is merging to main. While I was working on my feature branch, someone else may have made a change to the same file as me. This would create a merge conflict, and I would need to resolve the conflict by selecting from the overlapping changes. This hasn't happened here, so I'm free to enter a title and create the pull request. Everyone on the team can come into CodeCommit and review the changes on the Activity and Changes tabs. We can leave some comments and reply to other comments. Someone might suggest a neater way of coding what I'm doing. While the pull request is open, I'm free to keep pushing commits to the source branch, and the pull request will be updated. We've decided we are happy to go ahead with the pull request, so I can go ahead and merge.
# __
I have three options for the merge. Fast forward merge. This will only be enabled if the branches have not diverged. If there haven't been any commits on main since I branched, I can fast forward merge. Fast forward just moves the branch pointer along to include the source commits.
# __
Squash and merge combines all the commits from my source branch as a single commit added to the destination branch. 3-way merge, a merge commit is created with two parents in the destination branch. The commits from the source branch are now included in the destination branch. I'm going to pick squash and merge. This will also delete my source branch. The team has decided this is easier to read. The changes for this feature will appear as one commit. My work is now on the main branch. I'm ready to go to production. CI/CD will kick off, build, test, and deploy my code. And we are in production! We can go out for celebratory takeaway.
# __
The process that we have described here also works for our hotfix requirements. Let's say we found an issue in production. A library used in the application has a suspected security vulnerability. It doesn't seem fair. We didn't even cause the bug, but we want to work quickly to get a bugfix into production. Everyone else in the team can continue to work on their features. A hotfix branch is created from the main branch. I'm branching from the commit that is currently in production. We make the hotfix commits. We want to be sure we aren't introducing anything bad, or have caused a regression. Automated tests are run on the hotfix build. We might deploy to a staging environment for testing to make sure we have fixed the issue, and we haven't broken anything in the process. We merged back to main and CI/CD deploys our hotfix. This is a good example of how having a good DevOps practice, and automation in place, also is best for the security of our applications.
# __
Let's walk through one more scenario in the branching strategy. I have a big project. I've been working on a feature branch for several weeks. Other engineers have been working on features and bug fixes. So, my branch is now from an old commit. I've diverged pretty far from main. I have a big merger in my feature, and there is bound to be conflicts. And I don't know if my changes are going to be compatible with the current production code. To avoid this situation, I can bring the commits from main into my feature branch by merging, or rebasing, in my feature branch. If I git rebase main, first Git is going to take my new commits that are not in main, and save them in a temporary area. The feature branch is reset to main. This means the branch is now pointing to the same commit as the main branch. Then all the commits from the temporary area are replayed on the feature branch. A merge conflict could occur here, and we would need to resolve the conflicts. There's a little word of warning here. The replayed commits are new commits when you rebase your rewriting history. If the commits have already been pushed, then you will need to force the push to the feature branch. This will impact anyone who is working in the same feature branch. If you're the only one working on the branch, then, this only impacts you. Again, this is going to be a team decision, whether you're going to allow a false push.
# __
As an alternative, I can always git merge main in my feature branch. A merge commit will appear in my feature branch, and now the commits I was missing from the main branch will be included in my branch history. OK. That was a lot of information about branching. Ultimately, you and the team you're working with will decide the best approach for you. Git is a very powerful tool for this. The more you work with Git, the more this will become natural.
