![[index (1) 1.mp4]]
Hello, and welcome back. Now, let's take a deep dive on the application we'll be working with in this course. As you might already know, this course will focus on the processes and practices you would use in a software development team. Our focus isn't really on the application itself. We'll focus more on the steps it takes to get high-quality software in front of users and getting the best possible availability, or uptime, of the application. But yes, we do have an application. We've created one, so we can get hands-on with a close-to-real-world application. And here's my coworker, Russ, to show you that app. - [Russ] Let's see the application. From the application homepage, I can click Create a new game. I'm now presented with a link I can share with anyone who wants to join the game. And over on the right-hand side, I see a random color as my player name. I can share the link with other players.
# __
These players see a button to join the game. They can click Join game, and we see the updated player list on the right. Returning back to the initial player's screen, I click Start game, and we now get presented trivia questions.
# __
I can click an answer on the list and when the time runs out, I see the scores get updated on the right.
# __
The game gives everyone 10 questions, then shows us all a game over screen. Pause for a second and think about how you would architect an application like this. It would be interesting to see if we arrive at similar solutions. Feel free to share your ideas in the discussion forums.
# __
Let's talk about the architecture we used for this application. Think of this conversation like your first day on a new project. You may not be familiar with all the technology that is being used to build and host this application, but don't let that worry you, we will explain a lot of the technology as we progress. All of the code is supplied. And remember, our focus here will be the processes and practices. Let's start with the frontend. The web application is a React frontend, served from an Amazon Simple Storage Service, or S3, bucket.
# __
For this application, S3 is acting as our web server. We create several infrastructure resources to host the backend of the application. The frontend communicates to an API Gateway hosted WebSockets API. API Gateway is a fully managed service where we will host the application's API. When you click Create a new game, a WebSocket message is going from the browser to the WebSockets API. The backend compute resources are hosted in Lambda functions. Lambda is a serverless compute service where we can invoke our function code without having to provision or manage servers. We have six Lambda functions that are used to create, join, and start games, plus logic to send questions to players, accept answers, and calculate the scores. Where will we be storing the data for our application? For this, we'll use an Amazon DynamoDB table. DynamoDB is a fully managed key-value service and document database. When you create a new game or join a game, the application creates a new item in the TriviaConnections table. When you answer a question, the application is updating your item to remember the answer. We've started a game. We have rows in the TriviaConnections table for each connected player. Now, we need to track the state of the running game.
# __
What questions are players up to, pausing for players to answer, moving to a state to update player scores? For this, we'll use an AWS Step Functions state machine.
# __
The state machine has five states. When a game is started, we start a state machine execution and pass input data that contains a list of questions. The state machine execution starts at the question state. This calls the question Lambda function, which sends the current question to all the players. Next, we enter into a wait state while we allow players to submit their answers. Clicking an answer in the frontend sends a WebSocket message to the API, which calls the answer Lambda function. The Lambda function updates the DynamoDB item with the player's answer.
# __
Our wait state completes, and we move to the score state, where the calculate score function loops over the answers in the DynamoDB table, updates scores, and sends the scores to all the connected players. The state machine loops over the question, wait, and scores state, until we run out of questions. Now we enter into the game over state, where the state machine execution completes. We are using AWS services, API Gateway, S3, Lambda, DynamoDB, and Step Functions. We supply all the code. If you're familiar with Python for backend or React for frontend, you are more than welcome to pull apart the code and see how everything works.