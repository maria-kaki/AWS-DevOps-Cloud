![[index (3) 1.mp4]]
We've spoken about collaborating between software engineers using source control. And I have my code committed to a source repository. So, what comes next? Well, I'll most likely want to be sure my code is in a good state and it builds successfully. But what do we mean by a successful build? A build is going to take your source, compile it, retrieve dependency packages from a repository, like Node package manager, or npm, modules, or Java Maven artifact. The output of the build will be a packaged artifact ready for a deployment. Maybe this is a Linux RPM package, a Java WAR file, a Docker image, a Windows MSI installer, or many others. This is a package that can be passed on to your deployment process to roll out an update. A build will usually include automated testing to check the quality of the code, and unit tests to exercise the code, and make sure it's doing what we expect it to. We'll talk more about testing later.
# __
Now, if any of these steps-- such as retrieving dependencies, compiling, packaging, or testing--fail, we will have broken the build. This is something we want to catch as early as possible. If I commit something that is breaking the source control, I'm impacting others on the team. I can run a build in my local development environment, and when I do that, I can be pretty confident my code is in a good state. This is referred to as, it works on my machine. To get some extra confidence, we can perform the build in a clean environment off my laptop, somewhere to automate the build and test my code. But how often should we be checking that our code is successfully building? Well, why not do it on every commit? By doing this, we are now following continuous integration, or CI, practices.
# __
In every dev team I've worked in, a broken build takes the highest priority. When the code is in a good state, everyone on the team is confident they can pull the code and start working on their new features. If the code isn't in a good state, we're blocking others from integrating their changes. The team has decided on AWS CodeBuild for our continuous integration. This is the place where we can compile source, run tests, and create deployment packages. CodeBuild is a service. Unlike managing build machines yourself, CodeBuild will scale up and run multiple builds instead of leaving your build in a queue. With CodeBuild, you only pay for the service when you're using it.
# __
But how do we get our build processes into CodeBuild? There are two things that we need to configure, a build project and a buildspec file. The build project contains information about your build, like the source or location of your project, the environment, which will configure the project with a Docker image and specs of the build environments, and then CodeBuild will provision that and run your build.
# __
It will include an IAM role. Remember, roles are how services authenticate to services. If your build talks to an AWS service, this is the identity that will be used. And logging. Seeing the log output of the build is absolutely needed to debug your builds. We can configure CodeBuild to write logs to Amazon CloudWatch Logs and S3. So now that you have an understanding about what CodeBuild is, I'll pass it to Russ to give you more information about how to work with the service. - [Russ] Now, let's look at a buildspec file for a very simple project written in Go. This isn't a comprehensive review of every setting in a buildspec file. Let's just start with a simple build. I have a CodeCommit repository that contains three files, buildspec.yml, hello-world.go, and a readme file. hello-world.go is very simple. I just have two print calls. I plan to print the source version used to build the application. Hold on to that thought, I'll come back to this.
# __
The buildspec contains all the steps that we need to configure and run builds. I specify version, where version 0.2 is the current version of the buildspec format. I configure some environment variables. I can also use values retrieved from AWS Systems Manager Parameter Store and AWS Secrets Manager. The environment variables I have set are telling the Go compiler to build a macOS 64-bit binary. Next, we have the four build phases. The install phase is where I would install any prerequisite tools I need for my build. I don't have anything here because the container image supplied by CodeBuild has everything I need. The build phase is where my application is getting built. I'm using a little bit of scripting to replace the placeholder that we just saw. CodeBuild provide several environment variables with information about the build. I'm replacing the placeholder with the environment variable that contains the source version. For us, this will be the Git commit hash. In the reports section, we can point CodeBuild to the output of unit tests and code coverage reports. Let's talk more about this when we come back to testing. Next, in the artifacts section, we are telling CodeBuild the output we want packaged and delivered to the artifact's S3 bucket. I want to grab the readme and my newly built binary. And we have a setting to name the file hello-app and the date.zip. CodeBuild does support some caching features for builds that are CPU or network expensive. You can cache parts of your build in S3, or locally on the build server. We don't need this for a small project.
# __
Now, we can go to the console and create a build project for this repository. I choose Create build project. I give the project a name. Several different source providers are supported. My project is in CodeCommit, so I can select my CodeCommit repository and branch.
# __
I configure my environment settings. I want the Ubuntu Standard image. I could supply my own Docker image here. I would do this if the supplied images don't have the tools I want for my build.
# __
I also let the console create a role for me. My build will be writing to CloudWatch Logs and sending artifacts to S3. This role will be used to authenticate requests to those services. My buildspec is called buildspec.yml. That's actually the default. My build does have an artifact, so I select an S3 bucket as the destination for my artifact. And I enable semantic versioning because I want to use the artifact name from the buildspec. I also ask CodeBuild to zip the artifact for me. Logging is enabled, so I'll be able to see the output of my build in CloudWatch Logs. I can go ahead and click Create project. My project is created. I can start a build and tail the output logs. We see some information about the build here. The details are listed here, has been submitted. It has been queued, and it's currently provisioning. I see the output for my build. Here are the test echo statements that I had in my install and pre-build phases. And my build was successful. Now I can navigate to the build details and find the artifact that was just created. Here it is here, in S3. Let's copy that to my laptop, where we can execute it. I have downloaded that, let's unzip it. And there is the binary that was just built for me inside of CodeBuild. If I run the executable, I see the Git commit hash that was used for this build, because my build script substituted this into the code before it was built. Now, we've seen CodeBuild complete a very simple compile and package for us. Can you think of a build in your organization that could use CodeBuild? Using a fully managed service like CodeBuild would free you from maintaining your own build servers, and will scale as your requirements grow.