![[index (7) 1.mp4]]
We have our set of tests running in our local environments. As a new developer, coming on board to our projects, you can clone the source code and run tests. That way, you're confident you have the code in a good state. As you work on the code, you can keep adding to the tests and running existing tests to be sure that they aren't causing any regression. This is really just a test for it works on my machine. For example, I might forget to include a library in the source. But the library is present in my environment, so the build passes. But another developer clones the source and encounters errors, because the library isn't present. Breaking the build like this can have a pretty significant impact on your team productivity, while we trace through errors that are happening here, but not happening there. So we need to build and test in a clean environment off our laptops. We've already seen AWS CodeBuild for building and packaging an application, and running our tests. CodeBuild will provision a clean and consistent environment to install our test prerequisites, tools, and run tests. Here's Russ to show you a bit more about this. - [Russ] Let's compare the local build script and the buildspec used to run the same steps inside CodeBuild. The local build first runs Pylint with a single parameter. That's the location of the Lambda function code. Pylint is a static analyzer, or linter, for Python code. This tests that we are writing code to the same, standardized conventions. Things like variable naming and unused code will be detected here. Having a team coding convention will make the code less individualized. If we are all sticking to the same convention, code will be more predictable and easier to read for others on the team. Next, the code runs pytest. The parameters for pytest give the directory location of the unit tests. Then, the type of report we want, in this case, a HTML report. The last two parameters include code coverage and the tests. Code coverage will give us a report of which lines of code are being exercised by the tests. If I'm adding some conditional code to the application, this will show that the condition isn't being tested, if the code isn't being exercised. Now, let's look at how this would move to a buildspec file. This is going to look very similar to the steps you did manually, in the unit testing exercise. In the install phase, we installed two packages, we need to test the code. This is exactly what we did manually in our local environments. In the build phase, just like the local build, we have Pylint and pytest. This is very similar to the local build, but we're passing different parameters for the unit tests and the coverage report. Previously, we were building a HTML report for a human to read. This time, we want an XML report. The consumer of this report is going to be CodeBuild. Here, in the report section, we have settings that use the XML unit test report and the coverage report. CodeBuild supports several test file formats. For example, Cucumber, JUnit, NUnit. With this, we'll be able to see the results of our tests in the CodeBuild console. Now is a good time to talk about debugging and troubleshooting anything we are doing inside of CodeBuild. We are looking at a failed build. The first step of any debugging will be checking the logs. From inside the console, we've seen that we can see the output of a build. The output here is going to be the number one source of help when debugging. Okay, I've seen the output from my build. I think I have a fix. I could just commit the fix, but I want to get confident the fix will work before I push anything to the code repository. CodeBuild builds are run with a Docker image you configure. The Docker files used to create CodeBuild images are made available in a GitHub repository on your screen. I'll include a link to this in the course readings. You can build the same image CodeBuild is using to run your builds, and then launch this image locally to test your build. Let's see what this looks like. I cloned the Git repository. I'm interested in the Ubuntu Standard 5 image that is being used in the exercises. I can build the image on my laptop. There was a lot going into that image, but I already have it built on my laptop, so it completes pretty quickly. Let's launch a Bash shell inside of the container. I want to use my source inside the container. So I'll use a -v mount for my code. Inside the container, I have lots of build tools available, like Java, Python, Go, and Node on here. I can change over to the app directory, where I have my code mounted. From here, I can test my build commands, like go build. I see the same error I was seeing in the CodeBuild console. I can make a test fix in the container before I push anything to Git. Testing builds in a local Docker container makes it easy to test our builds in the same consistent environment that will be used by CodeBuild. What steps would you take if you still cannot reproduce your issue locally? Now, I would be thinking about using a Session Manager feature to connect to a running build. CodeBuild supports pausing the build, and using Session Manager to connect to the build container. To do this, there are three things I need in my build. To pause a build, I add a CodeBuild breakpoint command in the build phase of my buildspec file. I need to make sure the role associated with my build has permissions to create and open channels in AWS Systems Manager. Lastly, I need to launch the build with session connections enabled. Back inside the CodeBuild console, I can Start build with overrides. Advanced build overrides. And under Environment, I Enable session connection. The build will be submitted, queued, and provisioned. And once we're in the build phase, we'll pause the build and we'll be able to connect to it. I see a message telling me the build has paused, and I can connect to it with using Session Manager. Now in my browser, I'm inside a shell in the container, running my build. I'm going to have to launch a Bash shell. If I look at the environment variables, I see the environment variables that were set by CodeBuild. If I list the files in this directory, (typing) I see my code. I can use the commands that I would use in my build. I can now debug my build interactively. When I'm finished with my debugging, I can codebuild-resume, and the build will continue. Let's go over the three methods we use to debug a build. We have log output from builds. We can run the same containers CodeBuild uses in a local environment. And finally, we can pause the running build, and use Session Manager to connect to the build.