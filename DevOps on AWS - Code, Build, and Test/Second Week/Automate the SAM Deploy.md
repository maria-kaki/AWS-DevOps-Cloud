![[index (9) 1.mp4]]
You just completed a pipeline in the previous exercise. Meaning, that you are now meeting the continuous integration requirements. It is nice to see the pushes to the main branch result in starting a pipeline that runs tests. From now on, we are getting quick feedback on our code with every commit. Let's think about how could we extend this to continuous delivery. In a previous exercise, you manually use the AWS SAM CLI to deploy the backend, NPM to install the React application and dependencies, and the AWS CLI to copy the web app code to an S3 bucket. The good thing is that you can do all of this automatically as part of the pipeline with the same tools you were already familiar with. Russ is going to show you now. - [Russ] Let's start by looking at the new deployspec.yaml. In install phase, we use the pyenv utility to install the version of Python that we want. In the build phase, we're running some very similar commands to the commands that we used in the exercises. sam build prepares the backend resources, sam deploy deploys the AWS SAM application. We are passing an extra parameter here, - -no-fail-on-empty-changeset, because we don't want a no-changes deployment to break the build. Then we get into the npm install. This is pulling down the Node dependencies for the application. npm run build prepares the production HTML. aws s3 sync delivers the React application to our S3 bucket. This is very similar to the steps we had in the exercises, we're just handing this over to CodeBuild. I can commit and push this. So now, I have the new deployed buildspec in the CodeCommit repository. Next, we create a CodeBuild project that will run this for us. Back in the console, I go to CodeBuild, and I choose Create Project. I'm going to call this project trivia-deploy. For the source, I'm going to choose CodeCommit. The repository name, and the branch is main. For the environment, I'm going to use the Ubuntu standard image. I have already created a role for this project. Remember, the project is going to deploy Lambda functions, a Dynamo table, API Gateway, and Step Functions. We need a role that has permissions to create and update these resources. The buildspec file is the file that we just created. There are no artifacts for this project. I can click Create Build Project. Now, to add this to our pipeline. From the console, I can go to the trivia pipeline. I want to edit the pipeline and add a stage. Let's call this stage Deploy. Inside that stage, we create a single action. I'm going to call that Deploy, also. The action provider is CodeBuild. There are more ways to deploy your application. For what we are doing with the service application, CodeBuild works for us. If my application were being deployed to Elastic Compute Cloud, or Amazon EC2, I would consider using CodeDeploy. My input artifact is taken from the source artifact, which is the output of the source action. The project is trivia-deploy. I can leave everything else and choose Done. I can save my pipeline. Save. Let's see this run our pipeline by adding a commit to the application back in Cloud9. I'm going to make an obvious change to the application JavaScript. Instead of saying Get Started down here, let's change this to Let's GET STARTED, (typing) like that. I need to commit my change and push that to the repo. Adding the commit is going to initiate a build on the pipeline. Let's take a look at CodePipeline. Already, it has detected a change in the source. Let's give the pipeline some time to complete and we'll come back when the deploy action has completed. The brand-new deploy action has completed. I can click through to the details here. And I see the output logs from the deployment. At the start here, it is installing Python. The AWS SAM CLI is running the deploy for the backend changes here. I can see there was no changes to deploy down here. That's because we didn't make any changes to the backend, the change was just to the frontend code. That has completed. One of the last things that we'll see it do is here, when we S3 sync to deliver everything to the S3 bucket. So, we can return to the application. Refresh. And there, we see the change automatically deployed for us. We've built a continuous deployment pipeline. We have added to the source control all the knowledge that we need for a consistent, repeatable deployment. In a production environment, maybe we would add a few more controls in place to make sure we are very confident with the deploy. But in dev or staging, we can work fast. Testers and stakeholders can always see the build that is up-to-date with the latest code branch.
