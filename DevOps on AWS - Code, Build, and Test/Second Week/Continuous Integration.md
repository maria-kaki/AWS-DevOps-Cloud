![[index (8) 1.mp4]]
At this point, the application is source controlled, and I have automated tests I can run to make sure my code is in a good state. Pretty cool. But I want to run these tests every single time I commit code. This way, I receive immediate feedback that the code I've committed still works. So, if I wanted to automate these tests to run on every commit, how do I do it? Ideally, I need some kind of workflow, or orchestrator, that will do this for me, that will control the two different steps and decide when to go from the first step to the second step. Now, there's quite a few services on the market that were created to orchestrate steps of a pipeline, but the one we'll be talking about today is AWS CodePipeline. CodePipeline will let us establish a consistent set of steps that every code commit will run through. In our case, once we commit our code to a repository, we'll kick off another step that will run tests. So, we'll have a two-step pipeline. First step is commit to repository. Second step, run automated tests. The beauty of this is that once you set up your pipeline to include both of these steps, the pipeline is configured to detect any new commits to the repository. And then, it will restart the pipeline whenever those changes are detected, that means that all I have to do is push code to my repository, and that's it. CodePipeline will recognize there was a change and kick off the test phase, running my tests of choice. CodePipeline doesn't do all of this alone, though. Like I said, it's an orchestrator, and it teams up with other services, like CodeCommit and CodeBuild. It also integrates with third-party tools. So, while we might use CodeCommit for source control, you can also use GitHub in its place. Or, if you like to use Jenkins to build your code on every commit, you can do that as well. So, if you take the example of an orchestra, CodePipeline is the conductor, whereas all the services it integrates with-- like CodeCommit, CodeBuild, GitHub, Jenkins-- they're the musicians. They're doing the work, and CodePipeline is instructing them on how to do that work. As an example, let's see how CodeCommit, CodeBuild, and CodePipeline all work together. In CodePipeline, each workflow you create is called a pipeline. Each pipeline is made up of a series of stages. This is just a logical container that describes a phase in your pipeline, such as source, build, test, and deploy. So for our pipeline, we'll have two stages, Source and Test. For every stage, you have to decide what actions take place at that stage. This is where you can choose which service will be performing the action. For example, in my Source stage, I might have a source action that uses AWS CodeCommit. I'll then specify the specifics of what repository I want CodePipeline to monitor, and how I want it to monitor it for those changes. I also have a stage called Test, with an action called Test that uses CodeBuild.
# __
This will enable CodePipeline to kick off the appropriate build projects when it receives a new commit in the repository. This build project will point to the correct buildspec that will specify my tests. And that's really all I'll need for this very simple pipeline. When my pipeline runs, I can view my progress in real time. I can also see the status of each stage, whether it has succeeded, or not. And if it's failed, for whatever reason, I can go ahead and look at the action details, or I can even retry that action, or even kickstart the pipeline manually, if needed. Now, if I choose to, I can make this pipeline more complex, using other CodePipeline features. For example, maybe after my Test stage, I'll create a deploy stage, like what I just showed, but before we deploy, I want to manually approve the output of my tests. In CodePipeline, I can do this by creating an approval action, but to my testing stage, that will require me to manually approve or reject the action before it moves on to another stage. Using an orchestrator like CodePipeline is important to DevOps, because it can increase the speed and quality of your updates. For example, with our pipeline, now every commit gets tested without any manual intervention. And when we automate build and test for every commit, that enables us to achieve true continuous integration. That's all for this time, and I'll see you soon.