![[index (14).mp4]]
In the beginning of the week, I referenced a situation where a team of engineers wanted to practice continuous delivery, on top of the continuous integration system they already had in place. At this point, we've spent most of the week learning how to get code deployed. However, we've still been performing these deployments manually, which doesn't really solve the scenario I presented earlier. The goal of that team of engineers was to automate their build, test, and then deploy that code to a staging environment before it gets released, all automated. So, let's figure out how to do that with the information and services we know, so far. So, here I am in the AWS Management Console, and I've already set up a sample pipeline that looks like what the team already has in place. For this, I use AWS CodePipeline to model and configure the different stages of the team software-release process. Since they're already practicing continuous integration, it's likely that the team had a source phase and a test phase. As you can see, I've already set up the source stage to use AWS CodeCommit, and a test stage to run unit tests on their site. Now, we just need to configure a deploy stage to automate the deployment all the way from the repository to their staging environment. Okay. So, to make this quick, I've already created an application and a deployment group for CodeDeploy. So, I'll go ahead and edit the pipeline. And I'm going to add in a deployment. I'll click Add stage in the pipeline, after the test stage, and call it Staging, and then click Add stage again. From here, I'll go ahead and click Add action group. And this is where I'll specify what kind of action I want to take here, and which service I'm going to use to do it. I'll give it a name, call it something, like DeployToStaging. I'll select the service I want to use, which, in this case, will be CodeDeploy. And then, I'll then specify the input artifact that flows through the pipeline. If you remember, in an earlier video, where we walked you through CodeDeploy, we use the service by itself. When we used it as a standalone service, we had to specify the location of the artifact and an S3 bucket that we created. When you create a pipeline with CodePipeline, it creates an artifact bucket by default, and uses this bucket to store input and output artifacts, and also transfers them from stage to stage on your behalf. In fact, we can go into the S3 console and see this bucket. I'll go ahead and search for this bucket, with CodePipeline in the title. And then, I'll choose the one for the Region I'm in. In this case, it'll be us-west-2, and I'll click on it. I can select which pipeline I want, here. And, in this case, I'm using the CDpipeline in this demo. And then, I can view the files in it. As you can see here, there is a folder that has our source artifacts, which CodePipeline will transfer from stage to stage. All right. So, let's go back to the CodePipeline console, where we're back to creating a DeployToStaging action. If we use CodeDeploy with CodePipeline, as we're doing here, we'll simply specify the artifact that's in the bucket, and it takes care of the rest. I'll select the details about the application name, and deployment group. And then, I'll click Done. All right. From here, I'll click Save, and then Save again. Okay. And then we'll kick off the pipeline once more. So, I'll go into my terminal, here. I'll find my application, which is index.html, here. I'll make a change to the file, such as changing the font-size. Save the file.And then, I will git add the file, (typing) git commit with a message, such as, "changed the font size," and git push. Okay. So, once we've updated the file, we can go back to our pipeline, here. And I will give it a bit to run. All right. So, it looks like everything's succeeded here, and we've automated much of the process already. So, everything is good to go. Now, if we wanted the pipeline that released to production, we could simply add another stage here, to DeployToProd. I've already created a pipeline that adds on to this, that does just that. So, I'll go ahead and find that pipeline, click on it, and we can view the entire thing. Here is my source, test, the DeployToStaging, and then the DeployToProd. But, notice in the middle of these two deploy stages, I have a manual approval action. This is the point where I want the pipeline to stop so that someone can manually approve or reject this action. If everything looks good, it can be released. Otherwise, we'll need to troubleshoot and fix. This entire pipeline here is continuous delivery in action. It automates the deployment to the staging environments, and includes a manual step here to DeployToProd. So, with this pipeline in place, the team is now practicing continuous delivery.
(Obrigat√≥ria)
